{% extends "base.html" %}
{% block title %}Daily Feed Â· {{ target_date.strftime("%Y-%m-%d") }}{% endblock %}
{% block content %}
{% if not papers %}
  <div class="alert alert-info shadow-sm">No papers found for this date. Try another day.</div>
{% else %}
  {% set initial_limit = 24 %}
  <div class="feed-sections">
    {% for group in paper_groups %}
      {% set group_key = group['key'] %}
      {% set group_papers = group['papers'] %}
      {% if group_papers %}
        <section class="feed-section feed-section-{{ group_key }}">
          <header class="feed-section-header">
            <div class="d-flex flex-column gap-1">
              <div class="feed-section-title">{{ group['title'] }}</div>
              <div class="feed-section-subtitle">{{ group['subtitle'] }}</div>
            </div>
            <div class="feed-section-count">{{ group_papers|length }}</div>
          </header>

          <div class="feed-grid">
            {% set visible = group_papers[:initial_limit] %}
            {% for paper in visible %}
              {% set paper_meta = {'pos': loop.index, 'total': group_papers|length} %}
              {% include "_paper_item.html" %}
            {% endfor %}
          </div>

          {% if group_papers|length > initial_limit %}
            <div
              class="feed-more"
              data-group="{{ group_key }}"
              data-offset="{{ initial_limit }}"
              data-limit="24"
              role="status"
              aria-label="Load more">
              <button class="btn btn-sm btn-outline-secondary feed-more-btn" type="button">Load more</button>
              <span class="feed-more-hint text-muted small">Scroll to load more</span>
            </div>
          {% endif %}
        </section>
      {% endif %}
    {% endfor %}
  </div>
{% endif %}
<script>
  (() => {
    const copy = {{ lang_copy|tojson }};
    const csrfToken = {{ csrf_token|tojson }};
    let overlay = document.querySelector('.thumb-overlay');
    let imgEl;
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    const applyTransform = () => {
      if (!imgEl) return;
      imgEl.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    };

    const resetView = () => {
      scale = 1;
      translateX = 0;
      translateY = 0;
      applyTransform();
    };

    if (!overlay) {
      overlay = document.createElement('div');
      overlay.className = 'thumb-overlay';
      overlay.innerHTML = '<img alt="thumbnail preview"/>';
      document.body.appendChild(overlay);
      imgEl = overlay.querySelector('img');

      overlay.addEventListener('click', (e) => {
        if (e.target !== overlay) return;
        overlay.style.display = 'none';
        imgEl.src = '';
        resetView();
      });

      imgEl.addEventListener('click', (e) => e.stopPropagation());

      imgEl.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY;
        const factor = delta > 0 ? 0.9 : 1.1;
        scale *= factor;
        // Keep scale within a practical range to avoid runaway values
        scale = Math.min(Math.max(scale, 0.1), 12);
        applyTransform();
      });

      imgEl.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isDragging = true;
        dragStartX = e.clientX - translateX;
        dragStartY = e.clientY - translateY;
        imgEl.style.cursor = 'grabbing';
      });

      window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        translateX = e.clientX - dragStartX;
        translateY = e.clientY - dragStartY;
        applyTransform();
      });

      window.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          imgEl.style.cursor = 'grab';
        }
      });
    } else {
      imgEl = overlay.querySelector('img');
    }

    window.previewThumb = (src) => {
      if (!src) return;
      imgEl.src = src;
      overlay.style.display = 'flex';
      resetView();
    };

    // Favorites modal (lightweight)
    const favModal = document.createElement('div');
    favModal.className = 'modal fade';
    favModal.innerHTML = `
      <div class="modal-dialog modal-dialog-scrollable">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">${copy.modal_title}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <form id="favForm" class="d-flex flex-column gap-3">
              <input type="hidden" name="paper_id" id="favPaperId" value="">
              <input type="hidden" name="csrf_token" value="${csrfToken}">
              <div id="favList" class="fav-list-scroll text-muted small">${copy.modal_loading}</div>
              <div class="fav-actions">
                <div class="mb-3">
                  <label class="form-label">${copy.modal_new_label}</label>
                  <div class="input-group">
                    <input class="form-control" type="text" name="new_favorite_name" id="newFavoriteName" placeholder="${copy.modal_new_placeholder}">
                    <button class="btn btn-outline-primary" type="button" id="createFavoriteBtn">${copy.modal_create}</button>
                  </div>
                </div>
                <button class="btn btn-primary w-100" type="submit">${copy.modal_save}</button>
              </div>
            </form>
          </div>
        </div>
      </div>`;
    document.body.appendChild(favModal);
    let bsModal = null;
    let manualBackdrop = null;

    function showFavModal() {
      if (!bsModal && window.bootstrap) {
        bsModal = new bootstrap.Modal(favModal);
      }
      if (bsModal) {
        bsModal.show();
        return;
      }
      favModal.classList.add('show');
      favModal.style.display = 'block';
      favModal.removeAttribute('aria-hidden');
      favModal.setAttribute('aria-modal', 'true');
      if (!manualBackdrop) {
        manualBackdrop = document.createElement('div');
        manualBackdrop.className = 'modal-backdrop fade show';
        document.body.appendChild(manualBackdrop);
      }
    }

    function hideFavModal() {
      if (bsModal) {
        bsModal.hide();
        return;
      }
      favModal.classList.remove('show');
      favModal.style.display = 'none';
      favModal.setAttribute('aria-hidden', 'true');
      favModal.removeAttribute('aria-modal');
      if (manualBackdrop) {
        manualBackdrop.remove();
        manualBackdrop = null;
      }
    }

    const closeBtn = favModal.querySelector('.btn-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', (e) => {
        e.preventDefault();
        hideFavModal();
      });
    }

    window.openFavModal = (paperId, btnEl) => {
      const list = document.getElementById('favList');
      const form = document.getElementById('favForm');
      const createBtn = document.getElementById('createFavoriteBtn');
      const newFavInput = document.getElementById('newFavoriteName');
      document.getElementById('favPaperId').value = paperId;
      list.innerHTML = `<p class="text-muted small mb-2">${copy.modal_loading}</p>`;
      showFavModal();

      const getCheckedIds = () => {
        const ids = new Set();
        list.querySelectorAll('input[name="favorite_ids"]:checked').forEach(cb => {
          ids.add(String(cb.value));
        });
        return ids;
      };

      const populate = (data, opts = {}) => {
        const { autoCheckId = null, preserveChecked = null } = opts;
        const preserved = new Set((preserveChecked || []).map(v => String(v)));
        if (autoCheckId !== null && autoCheckId !== undefined) {
          preserved.add(String(autoCheckId));
        }
        list.innerHTML = '';
        const favs = data.favorites || [];
        let alreadyIn = false;
        if (favs.length) {
          favs.forEach(f => {
            const id = `modal-fav-${f.id}`;
            const simVal = typeof f.similarity === 'number' ? f.similarity : parseFloat(f.similarity);
            if (f.has_paper) alreadyIn = true;
            const shouldCheck = f.has_paper || f.is_top || preserved.has(String(f.id));
            const item = document.createElement('div');
            item.className = 'form-check';
            const checkbox = document.createElement('input');
            checkbox.className = 'form-check-input';
            checkbox.type = 'checkbox';
            checkbox.name = 'favorite_ids';
            checkbox.value = String(f.id);
            checkbox.id = id;
            checkbox.checked = Boolean(shouldCheck);
            const label = document.createElement('label');
            label.className = 'form-check-label';
            label.htmlFor = id;
            label.append(document.createTextNode(String(f.name ?? '')));
            if (Number.isFinite(simVal)) {
              const simSpan = document.createElement('span');
              simSpan.className = 'text-muted small';
              simSpan.textContent = `(${simVal.toFixed(2)})`;
              label.append(' ', simSpan);
            }
            item.appendChild(checkbox);
            item.appendChild(label);
            list.appendChild(item);
          });
        } else {
          list.innerHTML = `<p class="text-muted small mb-2">${copy.modal_empty}</p>`;
        }
        if (btnEl && alreadyIn) {
          markFavButton(btnEl, true);
        }
      };

      const fetchFavorites = () => {
        return fetch({{ url_for('feed.favorites_api')|tojson }} + '?paper_id=' + encodeURIComponent(paperId), {
          headers: { 'X-Requested-With': 'XMLHttpRequest' }
        }).then(res => res.ok ? res.json() : Promise.reject());
      };

      fetchFavorites()
        .then(data => populate(data))
        .catch(() => {
          list.innerHTML = `<p class="text-danger small">${copy.modal_error}</p>`;
        });

      const postSave = () => {
        const formData = new FormData(form);
        fetch({{ url_for('feed.add_to_favorites')|tojson }}, {
          method: 'POST',
          headers: {
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRFToken': csrfToken,
          },
          body: formData,
        }).then(res => {
          if (!res.ok) throw new Error();
          const contentType = res.headers.get('content-type') || '';
          if (contentType.includes('application/json')) {
            return res.json();
          }
          return {};
        }).then(payload => {
          hideFavModal();
          if (!btnEl) return;
          const saved = payload?.saved ?? (getCheckedIds().size > 0);
          markFavButton(btnEl, saved);
        }).catch(() => {
          hideFavModal();
        });
      };

      form.onsubmit = (e) => {
        e.preventDefault();
        postSave();
      };

      if (createBtn) {
        createBtn.onclick = () => {
          const name = (newFavInput?.value || '').trim();
          if (!name) return;
          const preserved = getCheckedIds();
          fetch({{ url_for('feed.create_favorite')|tojson }}, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'Accept': 'application/json',
              'X-Requested-With': 'XMLHttpRequest',
              'X-CSRFToken': csrfToken,
            },
            body: new URLSearchParams({ name, csrf_token: csrfToken })
          }).then(res => {
            if (!res.ok) throw new Error();
            return res.json().catch(() => ({}));
          }).then(payload => {
            const createdId = payload?.id;
            newFavInput.value = '';
            return fetchFavorites().then(data => populate(data, { autoCheckId: createdId, preserveChecked: preserved }));
          }).catch(() => {
            fetchFavorites().then(data => populate(data, { preserveChecked: preserved })).catch(() => {});
          });
        };
      }
    };

    function markFavButton(btn, active) {
      if (active) {
        btn.classList.remove('btn-outline-success');
        btn.classList.add('btn-success');
        btn.innerText = copy.favorite_saved;
        btn.dataset.saved = 'true';
      } else {
        btn.classList.add('btn-outline-success');
        btn.classList.remove('btn-success');
        btn.innerText = copy.favorite_unsaved;
        btn.dataset.saved = 'false';
      }
    }

    document.querySelectorAll('.fav-btn').forEach(btn => {
      const active = btn.dataset.saved === 'true';
      if (active) {
        markFavButton(btn, true);
      }
    });

    const targetDate = {{ target_date.strftime('%Y-%m-%d')|tojson }};
    const lastSeenId = {{ (history['paper_id'] if history else None)|tojson }};
    const lastPosition = {{ (history['position'] if history else 0)|tojson }};
    const cards = document.querySelectorAll('.paper-entry');
    let lastSeen = lastSeenId;

    if (lastPosition) {
      window.scrollTo({ top: lastPosition, behavior: 'auto' });
    } else if (lastSeenId) {
      const el = document.getElementById(`paper-${lastSeenId}`);
      if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    if (!cards.length) return;
    let saveTimeout;
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          lastSeen = entry.target.dataset.paperId;
          scheduleSave();
        }
      });
    }, { threshold: 0.5 });

    function observeCards(root = document) {
      root.querySelectorAll?.('.paper-entry')?.forEach(card => observer.observe(card));
    }

    observeCards(document);

    function scheduleSave() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        if (!csrfToken) return;
        if (!lastSeen) return;
        fetch({{ url_for('feed.save_history')|tojson }}, {
          method: 'POST',
          credentials: 'same-origin',
          keepalive: true,
          headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
          body: JSON.stringify({ paper_id: lastSeen, position: window.scrollY, date: targetDate, csrf_token: csrfToken })
        }).catch(() => {});
      }, 800);
    }

    // Incremental loading per section (avoids loading all thumbnails at once).
    const moreUrl = {{ url_for('feed.more')|tojson }};
    const moreObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (!entry.isIntersecting) return;
        const sentinel = entry.target;
        loadMoreForSentinel(sentinel);
      });
    }, { rootMargin: '600px 0px' });

    async function loadMoreForSentinel(sentinel) {
      if (!sentinel || sentinel.dataset.loading === '1') return;
      const group = sentinel.dataset.group || '';
      const offset = parseInt(sentinel.dataset.offset || '0', 10) || 0;
      const limit = parseInt(sentinel.dataset.limit || '24', 10) || 24;
      if (!group) return;

      sentinel.dataset.loading = '1';
      const btn = sentinel.querySelector('.feed-more-btn');
      if (btn) btn.disabled = true;

      const params = new URLSearchParams(window.location.search || '');
      params.set('group', group);
      params.set('offset', String(offset));
      params.set('limit', String(limit));

      try {
        const res = await fetch(moreUrl + '?' + params.toString(), { headers: { 'Accept': 'application/json' } });
        if (!res.ok) throw new Error('bad_status');
        const payload = await res.json();
        const html = payload?.html || '';
        if (html) {
          const section = sentinel.closest('.feed-section');
          const list = section?.querySelector('.feed-grid');
          if (list) {
            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            const appended = Array.from(wrapper.children);
            appended.forEach(node => list.appendChild(node));
            observeCards(list);
          }
        }
        const nextOffset = Number(payload?.next_offset ?? (offset + limit));
        const hasMore = Boolean(payload?.has_more);
        if (hasMore) {
          sentinel.dataset.offset = String(nextOffset);
          if (btn) btn.disabled = false;
          sentinel.dataset.loading = '0';
        } else {
          moreObserver.unobserve(sentinel);
          sentinel.remove();
        }
      } catch (_) {
        if (btn) btn.disabled = false;
        sentinel.dataset.loading = '0';
      }
    }

    document.querySelectorAll('.feed-more').forEach(sentinel => {
      const btn = sentinel.querySelector('.feed-more-btn');
      if (btn) {
        btn.addEventListener('click', () => loadMoreForSentinel(sentinel));
      }
      moreObserver.observe(sentinel);
    });
  })();
</script>
{% endblock %}
